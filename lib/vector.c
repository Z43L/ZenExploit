#include "../include/vector.h"
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_VECTORS 100
#define MAX_VECTORS_LONGITUD 1000

// Declaraciones estáticas para uso interno dentro de vector.c
static Vector vectors[MAX_VECTORS]; // Array estático para almacenar vectores de ataque.
static int vector_count = 0; // Contador de los vectores de ataque actualmente registrados.

// Variables globales para payloads, accesibles también desde fuera de vector.c
Payload payloads[MAX_PAYLOADS];
int payload_count = 0;

Vector* register_vector(Vector* vector) {
    if (vector_count >= MAX_VECTORS) {
        printf("Error: Se ha alcanzado el máximo número de vectores.\n");
        return NULL;
    }
    vectors[vector_count] = *vector;
    return &vectors[vector_count++];
}

Vector* get_vector_by_name(const char* name) {
    for (int i = 0; i < vector_count; i++) {
        if (strcmp(vectors[i].name, name) == 0) {
            return &vectors[i];
        }
    }
    return NULL;
}

void unregister_vector(Vector* vector) {
    for (int i = 0; i < vector_count; i++) {
        if (&vectors[i] == vector) {
            memmove(&vectors[i], &vectors[i + 1], sizeof(Vector) * (vector_count - i - 1));
            vector_count--;
            break;
        }
    }
}

void load_payloads_from_directory(const char* directory_path) {
    struct dirent *entry;
    DIR *dir = opendir(directory_path);

    if (dir == NULL) {
        perror("opendir");
        return;
    }

    while ((entry = readdir(dir)) != NULL && payload_count < MAX_PAYLOADS) {
        // Ignorar directorios "." y ".."
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        // Aquí asumimos que todos los archivos en el directorio son payloads
        // y que su nombre puede servir como identificador del payload.
        payloads[payload_count].name = strdup(entry->d_name);
        payloads[payload_count].filepath = malloc(strlen(directory_path) + strlen(entry->d_name) + 2);
        sprintf(payloads[payload_count].filepath, "%s/%s", directory_path, entry->d_name);
        payload_count++;
    }

    closedir(dir);
}

Payload* get_payload_by_name(const char* name) {
    for (int i = 0; i < payload_count; i++) {
        if (strcmp(payloads[i].name, name) == 0) {
            return &payloads[i];
        }
    }
    return NULL;
}

void free_payload(Payload* payload) {
    if (!payload) return;
    if (payload->name) free(payload->name);
    if (payload->filepath) free(payload->filepath);
    if (payload->data) free(payload->data);
    free(payload);
}

void list_all_vectors(void) {
    printf("Available attack vectors:\n");
    for (int i = 0; i < vector_count; i++) {
        printf("%d: %s - %s\n", i + 1, vectors[i].name, vectors[i].description);
    }
}
