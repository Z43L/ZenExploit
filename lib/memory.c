#include "memory.h"
#include <stdlib.h>
#include <sys/mman.h>
#include <stdbool.h>
#include <stddef.h>

typedef int MemoryProtection;

void* allocate_memory(size_t size, MemoryProtection protection) {
  int prot = 0;
  switch (protection) {
    case PROT_NONE:
      prot = PROT_NONE;
      break;
    case PROT_READ:
      prot = PROT_READ;
      break;
    case PROT_WRITE:
      prot = PROT_WRITE;
      break;
    case PROT_EXEC:
      prot = PROT_EXEC;
      break;
    default:
      return NULL;
  }
  void* ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  if (ptr == MAP_FAILED) {
    return NULL;
  }
  return ptr;
}

void free_memory(void* ptr) {
  munmap(ptr, 0);
}

void change_memory_protection(void* ptr, MemoryProtection protection) {
  int prot = 0;
  switch (protection) {
    case PROT_NONE:
      prot = PROT_NONE;
      break;
    case PROT_READ:
      prot = PROT_READ;
      break;
    case PROT_WRITE:
      prot = PROT_WRITE;
      break;
    case PROT_EXEC:
      prot = PROT_EXEC;
      break;
    default:
      return;
  }
  mprotect(ptr, 0, prot);
}

void* find_memory_pattern(void* start_address, size_t size, const void* pattern, size_t pattern_size) {
  uint8_t* ptr = (uint8_t*)start_address;
  uint8_t* pattern_ptr = (uint8_t*)pattern;
  for (size_t i = 0; i < size - pattern_size; i++) {
    bool match = true;
    for (size_t j = 0; j < pattern_size; j++) {
      if (ptr[i + j] != pattern_ptr[j]) {
        match = false;
        break;
      }
    }
    if (match) {
      return &ptr[i];
    }
  }
  return NULL;
}

void* add_to_pointer(void* ptr, ptrdiff_t offset) {
  return (void*)((uint8_t*)ptr + offset);
}

void* subtract_from_pointer(void* ptr, ptrdiff_t offset) {
  return (void*)((uint8_t*)ptr - offset);
}
