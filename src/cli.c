
#include "../include/api.h"
#include "../include/vector.h"
#include "../include/memory.h"
#include "../include/plugin_interface.h"
#include "../include/module_api.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void show_menu() {
    printf("\nExploitFrmwrk CLI\n");
    printf("1. List\n");
    printf("2. Configure payload\n");
    printf("3. Execute attack\n");
    printf("4. Reset configuration\n");
    printf("5. Start listener\n");
    printf("6. Exit\n");
    printf("Select an option: ");
}

void list_attack_vectors() {
    list_all_vectors();
}

void reset_configuration() {
    // Asegúrate de que globalConfig está correctamente definido y accesible
    // Esto puede requerir una declaración extern en el archivo de encabezado correspondiente si globalConfig está definido en otro lugar
    globalConfig.target_ip = "";
    globalConfig.target_port = 0;
    printf("la configuracion se a reiniciado ya puedes configurarla de nuevo para otro ataque\n");
}

void start_listener_interface() {
    int port;
    printf("Enter port to listen on: ");
    scanf("%d", &port);
    // Asegúrate de que start_listener esté correctamente definido y accesible
    start_listener(port);
}

void configure_payload() {
    char payload_name[100];
    printf("Enter payload name: ");
    fgets(payload_name, sizeof(payload_name), stdin);
    payload_name[strcspn(payload_name, "\n")] = 0; // Eliminar el salto de línea al final

    Payload* payload = get_payload_by_name(payload_name);
    if (payload == NULL) {
        printf("Payload not found.\n");
        return;
    }
    printf("Payload '%s' selected.\n", payload_name);

    printf("Enter new payload size: ");
    int new_size;
    scanf("%d", &new_size);
    while (getchar() != '\n'); // Limpiar el buffer de entrada
    payload->size = new_size;
}


void execute_attack() {
    char vector_name[100];
    printf("Enter attack vector name: ");
    scanf("%99s", vector_name);
    // Asegúrate de que get_vector_by_name esté correctamente definido y accesible
    Vector* vector = get_vector_by_name(vector_name);
    if (vector == NULL) {
        printf("Attack vector not found.\n");
        return;
    }
    if (vector->exploit_function != NULL) {
        printf("Executing attack usando vector '%s'...\n", vector_name);
        vector->exploit_function(NULL);
    } else {
        printf("No exploit function defined for this vector.\n");
    }
}
void banner() {
    printf("Zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n");
    printf("Zzzz    ZenExploit: Donde los Exploits encuentran el Zen    zzzZ\n");
    printf("Zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n");
    printf("\n");
    printf("    ZZZZZ   EEEEE N   N  N   N EEEEE X   X PPPP  L      OOO  I  TTTTT\n");
    printf("       Z    E     NN  N  NN  N E      X X  P   P L     O   O I    T  \n");
    printf("      Z     EEEE  N N N  N N N EEEE    X   PPPP  L     O   O I    T  \n");
    printf("     Z      E     N  NN  N  NN E      X X  P     L     O   O I    T  \n");
    printf("    ZZZZZ   EEEEE N   N  N   N EEEEE X   X P     LLLLL  OOO  I    T  \n");
    printf("\n");
    printf("Recuerda: El único límite es el que te pones a ti mismo.\n");
}
void interactive_shell() {
    int option;

    do {
        banner();
        show_menu();
        scanf("%d", &option);
        while (getchar() != '\n'); // Limpiar el buffer de entrada

        switch (option) {
            case 1:
                list_attack_vectors();
                break;
            case 2:
                configure_payload();
                break;
            case 3:
                execute_attack();
                break;
            case 4:
                reset_configuration();
                break;
            case 5:
                start_listener_interface();
                break;
            case 6:
                printf("Saliendo...\n");
                break;
            default:
                printf("opcion invalida prueba de nuevo.\n");
        }
        
    } while (option != 6);
    system("clear");
}
